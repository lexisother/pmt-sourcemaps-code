
        var process = self.process;
        if (!self.ZWITTERION_SOCKET && self.location.host.includes('localhost:')) {
            self.ZWITTERION_SOCKET = new WebSocket('ws://127.0.0.1:5001');
            self.ZWITTERION_SOCKET.addEventListener('message', (message) => {
                self.location.reload();
            });
        }
        "use strict";

const __1 = require("..");
const as_1 = require("../../as");
const utils_1 = require("../utils");
const path = require("path");
const fs = require("fs");
class IncludeBytesTransform extends __1.TransformVisitor {
  visitCallExpression(node) {
    if (node.expression instanceof as_1.IdentifierExpression) {
      if (node.expression.text == "includeBytes") {
        if (!node.args[0].isLiteralKind(as_1.LiteralKind.STRING)) throw "[Error] includeBytes requires a constant literal filename";
        let arg0 = node.args[0];
        let filename = path.join(path.dirname(node.range.source.normalizedPath), arg0.value);
        var data;
        try {
          data = fs.readFileSync(filename);
        } catch (e) {
          throw `[Error] includeBytes '${filename}', ${e}`;
        }
        let asJSONString = JSON.stringify(data); // use stringify to convert bytes to text
        let arrayStart = asJSONString.indexOf("["); //find the u8 array inside the JSON string
        let arrayEnd = asJSONString.lastIndexOf("]");
        let newCode = "StaticArray.fromArray<u8>(" + asJSONString.substring(arrayStart, arrayEnd + 1) + ")";
        let res = __1.SimpleParser.parseExpression(newCode); //parse StaticArray.fromArray expression
        res.range = node.range; //same range
        return res; //replace node
      }
    }

    return super.visitCallExpression(node);
  }
  afterParse(_) {
    let sources = _.sources.filter(utils_1.not(utils_1.isLibrary));
    this.visit(sources);
  }
}
module.exports = IncludeBytesTransform;
    