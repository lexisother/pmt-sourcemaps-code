
        var process = self.process;
        if (!self.ZWITTERION_SOCKET && self.location.host.includes('localhost:')) {
            self.ZWITTERION_SOCKET = new WebSocket('ws://127.0.0.1:5001');
            self.ZWITTERION_SOCKET.addEventListener('message', (message) => {
                self.location.reload();
            });
        }
        "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseVisitor = void 0;
const as_1 = require("../as");
const visitor_1 = require("./visitor");
class BaseVisitor extends visitor_1.AbstractVisitor {
  constructor() {
    super(...arguments);
    this.depth = 0;
  }
  _visit(node) {
    switch (node.kind) {
      case as_1.NodeKind.SOURCE:
        {
          this.visitSource(node);
          break;
        }
      // types
      case as_1.NodeKind.NAMEDTYPE:
        {
          this.visitNamedTypeNode(node);
          break;
        }
      case as_1.NodeKind.FUNCTIONTYPE:
        {
          this.visitFunctionTypeNode(node);
          break;
        }
      case as_1.NodeKind.TYPENAME:
        {
          this.visitTypeName(node);
        }
      case as_1.NodeKind.TYPEPARAMETER:
        {
          this.visitTypeParameter(node);
          break;
        }
      // expressions
      case as_1.NodeKind.FALSE:
      case as_1.NodeKind.NULL:
      case as_1.NodeKind.SUPER:
      case as_1.NodeKind.THIS:
      case as_1.NodeKind.TRUE:
      case as_1.NodeKind.CONSTRUCTOR:
      case as_1.NodeKind.IDENTIFIER:
        {
          this.visitIdentifierExpression(node);
          break;
        }
      case as_1.NodeKind.ASSERTION:
        {
          this.visitAssertionExpression(node);
          break;
        }
      case as_1.NodeKind.BINARY:
        {
          this.visitBinaryExpression(node);
          break;
        }
      case as_1.NodeKind.CALL:
        {
          this.visitCallExpression(node);
          break;
        }
      case as_1.NodeKind.CLASS:
        {
          this.visitClassExpression(node);
          break;
        }
      case as_1.NodeKind.COMMA:
        {
          this.visitCommaExpression(node);
          break;
        }
      case as_1.NodeKind.ELEMENTACCESS:
        {
          this.visitElementAccessExpression(node);
          break;
        }
      case as_1.NodeKind.FUNCTION:
        {
          this.visitFunctionExpression(node);
          break;
        }
      case as_1.NodeKind.INSTANCEOF:
        {
          this.visitInstanceOfExpression(node);
          break;
        }
      case as_1.NodeKind.LITERAL:
        {
          this.visitLiteralExpression(node);
          break;
        }
      case as_1.NodeKind.NEW:
        {
          this.visitNewExpression(node);
          break;
        }
      case as_1.NodeKind.PARENTHESIZED:
        {
          this.visitParenthesizedExpression(node);
          break;
        }
      case as_1.NodeKind.PROPERTYACCESS:
        {
          this.visitPropertyAccessExpression(node);
          break;
        }
      case as_1.NodeKind.TERNARY:
        {
          this.visitTernaryExpression(node);
          break;
        }
      case as_1.NodeKind.UNARYPOSTFIX:
        {
          this.visitUnaryPostfixExpression(node);
          break;
        }
      case as_1.NodeKind.UNARYPREFIX:
        {
          this.visitUnaryPrefixExpression(node);
          break;
        }
      // statements
      case as_1.NodeKind.BLOCK:
        {
          this.visitBlockStatement(node);
          break;
        }
      case as_1.NodeKind.BREAK:
        {
          this.visitBreakStatement(node);
          break;
        }
      case as_1.NodeKind.CONTINUE:
        {
          this.visitContinueStatement(node);
          break;
        }
      case as_1.NodeKind.DO:
        {
          this.visitDoStatement(node);
          break;
        }
      case as_1.NodeKind.EMPTY:
        {
          this.visitEmptyStatement(node);
          break;
        }
      case as_1.NodeKind.EXPORT:
        {
          this.visitExportStatement(node);
          break;
        }
      case as_1.NodeKind.EXPORTDEFAULT:
        {
          this.visitExportDefaultStatement(node);
          break;
        }
      case as_1.NodeKind.EXPORTIMPORT:
        {
          this.visitExportImportStatement(node);
          break;
        }
      case as_1.NodeKind.EXPRESSION:
        {
          this.visitExpressionStatement(node);
          break;
        }
      case as_1.NodeKind.FOR:
        {
          this.visitForStatement(node);
          break;
        }
      case as_1.NodeKind.IF:
        {
          this.visitIfStatement(node);
          break;
        }
      case as_1.NodeKind.IMPORT:
        {
          this.visitImportStatement(node);
          break;
        }
      case as_1.NodeKind.RETURN:
        {
          this.visitReturnStatement(node);
          break;
        }
      case as_1.NodeKind.SWITCH:
        {
          this.visitSwitchStatement(node);
          break;
        }
      case as_1.NodeKind.THROW:
        {
          this.visitThrowStatement(node);
          break;
        }
      case as_1.NodeKind.TRY:
        {
          this.visitTryStatement(node);
          break;
        }
      case as_1.NodeKind.VARIABLE:
        {
          this.visitVariableStatement(node);
          break;
        }
      case as_1.NodeKind.WHILE:
        {
          this.visitWhileStatement(node);
          break;
        }
      // declaration statements
      case as_1.NodeKind.CLASSDECLARATION:
        {
          this.visitClassDeclaration(node);
          break;
        }
      case as_1.NodeKind.ENUMDECLARATION:
        {
          this.visitEnumDeclaration(node);
          break;
        }
      case as_1.NodeKind.ENUMVALUEDECLARATION:
        {
          this.visitEnumValueDeclaration(node);
          break;
        }
      case as_1.NodeKind.FIELDDECLARATION:
        {
          this.visitFieldDeclaration(node);
          break;
        }
      case as_1.NodeKind.FUNCTIONDECLARATION:
        {
          this.visitFunctionDeclaration(node);
          break;
        }
      case as_1.NodeKind.IMPORTDECLARATION:
        {
          this.visitImportDeclaration(node);
          break;
        }
      case as_1.NodeKind.INTERFACEDECLARATION:
        {
          this.visitInterfaceDeclaration(node);
          break;
        }
      case as_1.NodeKind.METHODDECLARATION:
        {
          this.visitMethodDeclaration(node);
          break;
        }
      case as_1.NodeKind.NAMESPACEDECLARATION:
        {
          this.visitNamespaceDeclaration(node);
          break;
        }
      case as_1.NodeKind.TYPEDECLARATION:
        {
          this.visitTypeDeclaration(node);
          break;
        }
      case as_1.NodeKind.VARIABLEDECLARATION:
        {
          this.visitVariableDeclaration(node);
          break;
        }
      // other
      case as_1.NodeKind.DECORATOR:
        {
          this.visitDecoratorNode(node);
          break;
        }
      case as_1.NodeKind.EXPORTMEMBER:
        {
          this.visitExportMember(node);
          break;
        }
      case as_1.NodeKind.PARAMETER:
        {
          this.visitParameter(node);
          break;
        }
      case as_1.NodeKind.SWITCHCASE:
        {
          this.visitSwitchCase(node);
          break;
        }
      case as_1.NodeKind.INDEXSIGNATURE:
        {
          this.visitIndexSignature(node);
          break;
        }
      default:
        assert(false);
    }
  }
  visitSource(node) {
    for (const stmt of node.statements) {
      this.depth++;
      this.visit(stmt);
      this.depth--;
    }
  }
  visitTypeNode(node) {}
  visitTypeName(node) {
    this.visit(node.identifier);
    if (node.next) {
      this.visit(node.next);
    }
  }
  visitNamedTypeNode(node) {
    this.visit(node.name);
    this.visit(node.typeArguments);
  }
  visitFunctionTypeNode(node) {
    for (let param of node.parameters) {
      this.visitParameter(param);
    }
    this.visit(node.returnType);
  }
  visitTypeParameter(node) {
    this.visit(node.name);
    if (node.extendsType) this.visit(node.extendsType);
    if (node.defaultType) this.visit(node.defaultType);
  }
  visitIdentifierExpression(node) {}
  visitArrayLiteralExpression(node) {
    node.elementExpressions.map(e => {
      if (e) this.visit(e);
    });
  }
  visitObjectLiteralExpression(node) {
    if (node.values && node.names) {
      assert(node.values.length == node.names.length);
      for (let i = 0; i < node.values.length; i++) {
        this.visit(node.names[i]);
        this.visit(node.values[i]);
      }
    }
  }
  visitAssertionExpression(node) {
    if (node.toType) this.visit(node.toType);
    this.visit(node.expression);
  }
  visitBinaryExpression(node) {
    this.visit(node.left);
    this.visit(node.right);
  }
  visitCallExpression(node) {
    this.visit(node.expression);
    this.visitArguments(node.typeArguments, node.args);
  }
  visitArguments(typeArguments, args) {}
  visitClassExpression(node) {
    this.visit(node.declaration);
  }
  visitCommaExpression(node) {
    this.visit(node.expressions);
  }
  visitElementAccessExpression(node) {
    this.visit(node.elementExpression);
    this.visit(node.expression);
  }
  visitFunctionExpression(node) {
    this.visit(node.declaration);
  }
  visitLiteralExpression(node) {
    switch (node.literalKind) {
      case as_1.LiteralKind.FLOAT:
        {
          this.visitFloatLiteralExpression(node);
          break;
        }
      case as_1.LiteralKind.INTEGER:
        {
          this.visitIntegerLiteralExpression(node);
          break;
        }
      case as_1.LiteralKind.STRING:
        {
          this.visitStringLiteralExpression(node);
          break;
        }
      case as_1.LiteralKind.TEMPLATE:
        {
          this.visitTemplateLiteralExpression(node);
          break;
        }
      case as_1.LiteralKind.REGEXP:
        {
          this.visitRegexpLiteralExpression(node);
          break;
        }
      case as_1.LiteralKind.ARRAY:
        {
          this.visitArrayLiteralExpression(node);
          break;
        }
      case as_1.LiteralKind.OBJECT:
        {
          this.visitObjectLiteralExpression(node);
          break;
        }
      default:
        throw new Error("Invalid LiteralKind: " + node.literalKind);
    }
  }
  visitFloatLiteralExpression(node) {}
  visitInstanceOfExpression(node) {
    this.visit(node.expression);
    this.visit(node.isType);
  }
  visitIntegerLiteralExpression(node) {}
  visitStringLiteral(str, singleQuoted) {}
  visitStringLiteralExpression(node) {
    this.visitStringLiteral(node.value);
  }
  visitTemplateLiteralExpression(node) {}
  visitRegexpLiteralExpression(node) {}
  visitNewExpression(node) {
    this.visit(node.typeArguments);
    this.visitArguments(node.typeArguments, node.args);
  }
  visitParenthesizedExpression(node) {
    this.visit(node.expression);
  }
  visitPropertyAccessExpression(node) {
    this.visit(node.property);
    this.visit(node.expression);
  }
  visitTernaryExpression(node) {
    this.visit(node.condition);
    this.visit(node.ifThen);
    this.visit(node.ifElse);
  }
  visitUnaryExpression(node) {
    this.visit(node.operand);
  }
  visitUnaryPostfixExpression(node) {
    this.visit(node.operand);
  }
  visitUnaryPrefixExpression(node) {
    this.visit(node.operand);
  }
  visitSuperExpression(node) {}
  visitFalseExpression(node) {}
  visitTrueExpression(node) {}
  visitThisExpression(node) {}
  visitNullExperssion(node) {}
  visitConstructorExpression(node) {}
  visitNodeAndTerminate(statement) {}
  visitBlockStatement(node) {
    this.depth++;
    this.visit(node.statements);
    this.depth--;
  }
  visitBreakStatement(node) {
    if (node.label) {
      this.visit(node.label);
    }
  }
  visitContinueStatement(node) {
    if (node.label) {
      this.visit(node.label);
    }
  }
  visitClassDeclaration(node, isDefault) {
    this.visit(node.name);
    this.depth++;
    this.visit(node.decorators);
    assert(node.isGeneric ? node.typeParameters != null : node.typeParameters == null);
    if (node.isGeneric) {
      this.visit(node.typeParameters);
    }
    if (node.extendsType) {
      this.visit(node.extendsType);
    }
    this.visit(node.implementsTypes);
    this.visit(node.members);
    this.depth--;
  }
  visitDoStatement(node) {
    this.visit(node.condition);
    this.visit(node.statement);
  }
  visitEmptyStatement(node) {}
  visitEnumDeclaration(node, isDefault) {
    this.visit(node.name);
    this.visit(node.decorators);
    this.visit(node.values);
  }
  visitEnumValueDeclaration(node) {
    this.visit(node.name);
    if (node.initializer) {
      this.visit(node.initializer);
    }
  }
  visitExportImportStatement(node) {
    this.visit(node.name);
    this.visit(node.externalName);
  }
  visitExportMember(node) {
    this.visit(node.localName);
    this.visit(node.exportedName);
  }
  visitExportStatement(node) {
    if (node.path) {
      this.visit(node.path);
    }
    this.visit(node.members);
  }
  visitExportDefaultStatement(node) {
    this.visit(node.declaration);
  }
  visitExpressionStatement(node) {
    this.visit(node.expression);
  }
  visitFieldDeclaration(node) {
    this.visit(node.name);
    if (node.type) {
      this.visit(node.type);
    }
    if (node.initializer) {
      this.visit(node.initializer);
    }
    this.visit(node.decorators);
  }
  visitForStatement(node) {
    if (node.initializer) this.visit(node.initializer);
    if (node.condition) this.visit(node.condition);
    if (node.incrementor) this.visit(node.incrementor);
    this.visit(node.statement);
  }
  visitFunctionDeclaration(node, isDefault) {
    this.visit(node.name);
    this.visit(node.decorators);
    if (node.isGeneric) {
      this.visit(node.typeParameters);
    }
    this.visit(node.signature);
    this.depth++;
    if (node.body) this.visit(node.body);
    this.depth--;
  }
  visitFunctionCommon(node) {
    // this.visit(node.name)
  }
  visitIfStatement(node) {
    this.visit(node.condition);
    this.visit(node.ifTrue);
    if (node.ifFalse) this.visit(node.ifFalse);
  }
  visitImportDeclaration(node) {
    this.visit(node.foreignName);
    this.visit(node.name);
    this.visit(node.decorators);
  }
  visitImportStatement(node) {
    if (node.namespaceName) this.visit(node.namespaceName);
    this.visit(node.declarations);
  }
  visitIndexSignature(node) {
    // this.visit(node.name);
    // this.visit(node.keyType);
    // this.visit(node.valueType);
  }
  visitInterfaceDeclaration(node, isDefault) {
    this.visit(node.name);
    if (node.isGeneric) {
      this.visit(node.typeParameters);
    }
    this.visit(node.implementsTypes);
    if (node.extendsType) this.visit(node.extendsType);
    this.depth++;
    this.visit(node.members);
    this.depth--;
  }
  visitMethodDeclaration(node) {
    this.visit(node.name);
    if (node.isGeneric) {
      this.visit(node.typeParameters);
    }
    this.visit(node.signature);
    this.visit(node.decorators);
    this.depth++;
    if (node.body) this.visit(node.body);
    this.depth--;
  }
  visitNamespaceDeclaration(node, isDefault) {
    this.visit(node.name);
    this.visit(node.decorators);
    this.visit(node.members);
  }
  visitReturnStatement(node) {
    if (node.value) this.visit(node.value);
  }
  visitSwitchCase(node) {
    if (node.label) this.visit(node.label);
    this.visit(node.statements);
  }
  visitSwitchStatement(node) {
    this.visit(node.condition);
    this.depth++;
    this.visit(node.cases);
    this.depth--;
  }
  visitThrowStatement(node) {
    this.visit(node.value);
  }
  visitTryStatement(node) {
    this.visit(node.statements);
    if (node.catchVariable) this.visit(node.catchVariable);
    this.visit(node.catchStatements);
    this.visit(node.finallyStatements);
  }
  visitTypeDeclaration(node) {
    this.visit(node.name);
    this.visit(node.decorators);
    this.visit(node.type);
    this.visit(node.typeParameters);
  }
  visitVariableDeclaration(node) {
    this.visit(node.name);
    if (node.type) this.visit(node.type);
    if (node.initializer) this.visit(node.initializer);
  }
  visitVariableStatement(node) {
    this.visit(node.decorators);
    this.visit(node.declarations);
  }
  visitWhileStatement(node) {
    this.visit(node.condition);
    this.depth++;
    this.visit(node.statement);
    this.depth--;
  }
  visitVoidStatement(node) {}
  visitComment(node) {}
  visitDecoratorNode(node) {
    this.visit(node.name);
    this.visit(node.args);
  }
  visitParameter(node) {
    this.visit(node.name);
    if (node.implicitFieldDeclaration) {
      this.visit(node.implicitFieldDeclaration);
    }
    if (node.initializer) this.visit(node.initializer);
    this.visit(node.type);
  }
}
exports.BaseVisitor = BaseVisitor;
    