
        var process = self.process;
        if (!self.ZWITTERION_SOCKET && self.location.host.includes('localhost:')) {
            self.ZWITTERION_SOCKET = new WebSocket('ws://127.0.0.1:5001');
            self.ZWITTERION_SOCKET.addEventListener('message', (message) => {
                self.location.reload();
            });
        }
        "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseTransformVisitor = void 0;
const as_1 = require("../as");
const visitor_1 = require("./visitor");
class BaseTransformVisitor extends visitor_1.AbstractTransformVisitor {
  constructor() {
    super(...arguments);
    this.depth = 0;
  }
  _visit(node) {
    switch (node.kind) {
      case as_1.NodeKind.SOURCE:
        {
          return this.visitSource(node);
        }
      // types
      case as_1.NodeKind.NAMEDTYPE:
        {
          return this.visitNamedTypeNode(node);
        }
      case as_1.NodeKind.FUNCTIONTYPE:
        {
          return this.visitFunctionTypeNode(node);
        }
      case as_1.NodeKind.TYPENAME:
        {
          return this.visitTypeName(node);
        }
      case as_1.NodeKind.TYPEPARAMETER:
        {
          return this.visitTypeParameter(node);
        }
      // expressions
      case as_1.NodeKind.FALSE:
      case as_1.NodeKind.NULL:
      case as_1.NodeKind.SUPER:
      case as_1.NodeKind.THIS:
      case as_1.NodeKind.TRUE:
      case as_1.NodeKind.CONSTRUCTOR:
      case as_1.NodeKind.IDENTIFIER:
        {
          return this.visitIdentifierExpression(node);
        }
      case as_1.NodeKind.ASSERTION:
        {
          return this.visitAssertionExpression(node);
        }
      case as_1.NodeKind.BINARY:
        {
          return this.visitBinaryExpression(node);
        }
      case as_1.NodeKind.CALL:
        {
          return this.visitCallExpression(node);
        }
      case as_1.NodeKind.CLASS:
        {
          return this.visitClassExpression(node);
        }
      case as_1.NodeKind.COMMA:
        {
          return this.visitCommaExpression(node);
        }
      case as_1.NodeKind.ELEMENTACCESS:
        {
          return this.visitElementAccessExpression(node);
        }
      case as_1.NodeKind.FUNCTION:
        {
          return this.visitFunctionExpression(node);
        }
      case as_1.NodeKind.INSTANCEOF:
        {
          return this.visitInstanceOfExpression(node);
        }
      case as_1.NodeKind.LITERAL:
        {
          return this.visitLiteralExpression(node);
        }
      case as_1.NodeKind.NEW:
        {
          return this.visitNewExpression(node);
        }
      case as_1.NodeKind.PARENTHESIZED:
        {
          return this.visitParenthesizedExpression(node);
        }
      case as_1.NodeKind.PROPERTYACCESS:
        {
          return this.visitPropertyAccessExpression(node);
        }
      case as_1.NodeKind.TERNARY:
        {
          return this.visitTernaryExpression(node);
        }
      case as_1.NodeKind.UNARYPOSTFIX:
        {
          return this.visitUnaryPostfixExpression(node);
        }
      case as_1.NodeKind.UNARYPREFIX:
        {
          return this.visitUnaryPrefixExpression(node);
        }
      // statements
      case as_1.NodeKind.BLOCK:
        {
          return this.visitBlockStatement(node);
        }
      case as_1.NodeKind.BREAK:
        {
          return this.visitBreakStatement(node);
        }
      case as_1.NodeKind.CONTINUE:
        {
          return this.visitContinueStatement(node);
        }
      case as_1.NodeKind.DO:
        {
          return this.visitDoStatement(node);
        }
      case as_1.NodeKind.EMPTY:
        {
          return this.visitEmptyStatement(node);
        }
      case as_1.NodeKind.EXPORT:
        {
          return this.visitExportStatement(node);
        }
      case as_1.NodeKind.EXPORTDEFAULT:
        {
          return this.visitExportDefaultStatement(node);
        }
      case as_1.NodeKind.EXPORTIMPORT:
        {
          return this.visitExportImportStatement(node);
        }
      case as_1.NodeKind.EXPRESSION:
        {
          return this.visitExpressionStatement(node);
        }
      case as_1.NodeKind.FOR:
        {
          return this.visitForStatement(node);
        }
      case as_1.NodeKind.IF:
        {
          return this.visitIfStatement(node);
        }
      case as_1.NodeKind.IMPORT:
        {
          return this.visitImportStatement(node);
        }
      case as_1.NodeKind.RETURN:
        {
          return this.visitReturnStatement(node);
        }
      case as_1.NodeKind.SWITCH:
        {
          return this.visitSwitchStatement(node);
        }
      case as_1.NodeKind.THROW:
        {
          return this.visitThrowStatement(node);
        }
      case as_1.NodeKind.TRY:
        {
          return this.visitTryStatement(node);
        }
      case as_1.NodeKind.VARIABLE:
        {
          return this.visitVariableStatement(node);
        }
      case as_1.NodeKind.WHILE:
        {
          return this.visitWhileStatement(node);
        }
      // declaration statements
      case as_1.NodeKind.CLASSDECLARATION:
        {
          return this.visitClassDeclaration(node);
        }
      case as_1.NodeKind.ENUMDECLARATION:
        {
          return this.visitEnumDeclaration(node);
        }
      case as_1.NodeKind.ENUMVALUEDECLARATION:
        {
          return this.visitEnumValueDeclaration(node);
        }
      case as_1.NodeKind.FIELDDECLARATION:
        {
          return this.visitFieldDeclaration(node);
        }
      case as_1.NodeKind.FUNCTIONDECLARATION:
        {
          return this.visitFunctionDeclaration(node);
        }
      case as_1.NodeKind.IMPORTDECLARATION:
        {
          return this.visitImportDeclaration(node);
        }
      case as_1.NodeKind.INTERFACEDECLARATION:
        {
          return this.visitInterfaceDeclaration(node);
        }
      case as_1.NodeKind.METHODDECLARATION:
        {
          return this.visitMethodDeclaration(node);
        }
      case as_1.NodeKind.NAMESPACEDECLARATION:
        {
          return this.visitNamespaceDeclaration(node);
        }
      case as_1.NodeKind.TYPEDECLARATION:
        {
          return this.visitTypeDeclaration(node);
        }
      case as_1.NodeKind.VARIABLEDECLARATION:
        {
          return this.visitVariableDeclaration(node);
        }
      // other
      case as_1.NodeKind.DECORATOR:
        {
          return this.visitDecoratorNode(node);
        }
      case as_1.NodeKind.EXPORTMEMBER:
        {
          return this.visitExportMember(node);
        }
      case as_1.NodeKind.PARAMETER:
        {
          return this.visitParameter(node);
        }
      case as_1.NodeKind.SWITCHCASE:
        {
          return this.visitSwitchCase(node);
        }
      case as_1.NodeKind.INDEXSIGNATURE:
        {
          return this.visitIndexSignature(node);
        }
      default:
        assert(false);
    }
    return node;
  }
  visitStatement(node) {
    return node = this.visit(node);
  }
  visitSource(node) {
    let statements = [];
    for (const stmt of node.statements) {
      this.depth++;
      statements.push(this.visitStatement(stmt));
      this.depth--;
    }
    node.statements = statements;
    return node;
  }
  visitTypeNode(node) {
    return node;
  }
  visitTypeName(node) {
    node.identifier = this.visitIdentifierExpression(node.identifier);
    if (node.next) {
      node.next = this.visit(node.next);
    }
    return node;
  }
  visitNamedTypeNode(node) {
    node.name = this.visit(node.name);
    node.typeArguments = this.visit(node.typeArguments);
    return node;
  }
  visitFunctionTypeNode(node) {
    let params = [];
    for (let param of node.parameters) {
      params.push(this.visitParameter(param));
    }
    node.parameters = params;
    node.returnType = this.visit(node.returnType);
    return node;
  }
  visitTypeParameter(node) {
    node.name = this.visit(node.name);
    if (node.extendsType) node.extendsType = this.visit(node.extendsType);
    if (node.defaultType) node.defaultType = this.visit(node.defaultType);
    return node;
  }
  visitIdentifierExpression(node) {
    return node;
  }
  visitArrayLiteralExpression(node) {
    node.elementExpressions = node.elementExpressions.map(e => this.visit(e));
    return node;
  }
  visitObjectLiteralExpression(node) {
    if (node.values && node.names) {
      assert(node.values.length == node.names.length);
      for (let i = 0; i < node.values.length; i++) {
        node.names[i] = this.visit(node.names[i]);
        node.values[i] = this.visit(node.values[i]);
      }
    }
    return node;
  }
  visitAssertionExpression(node) {
    if (node.toType) node.toType = this.visit(node.toType);
    node.expression = this.visit(node.expression);
    return node;
  }
  visitBinaryExpression(node) {
    node.left = this.visit(node.left);
    node.right = this.visit(node.right);
    return node;
  }
  visitCallExpression(node) {
    node.expression = this.visit(node.expression);
    node.typeArguments = this.visit(node.typeArguments);
    node.args = this.visit(node.args);
    this.visitArguments(node.typeArguments, node.args);
    return node;
  }
  visitArguments(typeArguments, args) {}
  visitClassExpression(node) {
    node.declaration = this.visit(node.declaration);
    return node;
  }
  visitCommaExpression(node) {
    node.expressions = this.visit(node.expressions);
    return node;
  }
  visitElementAccessExpression(node) {
    node.elementExpression = this.visit(node.elementExpression);
    node.expression = this.visit(node.expression);
    return node;
  }
  visitFunctionExpression(node) {
    node.declaration = this.visit(node.declaration);
    return node;
  }
  visitLiteralExpression(node) {
    switch (node.literalKind) {
      case as_1.LiteralKind.ARRAY:
        {
          return this.visitArrayLiteralExpression(node);
        }
      case as_1.LiteralKind.FLOAT:
        {
          return this.visitFloatLiteralExpression(node);
        }
      case as_1.LiteralKind.INTEGER:
        {
          return this.visitIntegerLiteralExpression(node);
        }
      case as_1.LiteralKind.OBJECT:
        {
          return this.visitObjectLiteralExpression(node);
        }
      case as_1.LiteralKind.REGEXP:
        {
          return this.visitRegexpLiteralExpression(node);
        }
      case as_1.LiteralKind.STRING:
        {
          return this.visitStringLiteralExpression(node);
        }
      case as_1.LiteralKind.TEMPLATE:
        {
          return this.visitTemplateLiteralExpression(node);
        }
      default:
        throw new Error("Invalid LiteralKind: " + node.literalKind);
    }
  }
  visitFloatLiteralExpression(node) {
    return node;
  }
  visitInstanceOfExpression(node) {
    node.expression = this.visit(node.expression);
    node.isType = this.visit(node.isType);
    return node;
  }
  visitIntegerLiteralExpression(node) {
    return node;
  }
  visitStringLiteral(str, singleQuoted) {
    return str;
  }
  visitStringLiteralExpression(node) {
    node.value = this.visitStringLiteral(node.value);
    return node;
  }
  visitTemplateLiteralExpression(node) {
    return node;
  }
  visitRegexpLiteralExpression(node) {
    return node;
  }
  visitNewExpression(node) {
    node.typeArguments = this.visit(node.typeArguments);
    this.visitArguments(node.typeArguments, node.args);
    return node;
  }
  visitParenthesizedExpression(node) {
    node.expression = this.visit(node.expression);
    return node;
  }
  visitPropertyAccessExpression(node) {
    node.property = this.visit(node.property);
    node.expression = this.visit(node.expression);
    return node;
  }
  visitTernaryExpression(node) {
    node.condition = this.visit(node.condition);
    node.ifThen = this.visit(node.ifThen);
    node.ifElse = this.visit(node.ifElse);
    return node;
  }
  visitUnaryExpression(node) {
    node.operand = this.visit(node.operand);
    return node;
  }
  visitUnaryPostfixExpression(node) {
    node.operand = this.visit(node.operand);
    return node;
  }
  visitUnaryPrefixExpression(node) {
    node.operand = this.visit(node.operand);
    return node;
  }
  visitSuperExpression(node) {
    return node;
  }
  visitFalseExpression(node) {
    return node;
  }
  visitTrueExpression(node) {
    return node;
  }
  visitThisExpression(node) {
    return node;
  }
  visitNullExperssion(node) {
    return node;
  }
  visitConstructorExpression(node) {
    return node;
  }
  visitNodeAndTerminate(node) {
    return node;
  }
  visitBlockStatement(node) {
    this.depth++;
    node.statements = this.visit(node.statements);
    this.depth--;
    return node;
  }
  visitBreakStatement(node) {
    if (node.label) {
      node.label = this.visit(node.label);
    }
    return node;
  }
  visitContinueStatement(node) {
    if (node.label) {
      node.label = this.visit(node.label);
    }
    return node;
  }
  visitClassDeclaration(node, isDefault) {
    node.name = this.visit(node.name);
    this.depth++;
    node.decorators = this.visit(node.decorators);
    assert(node.isGeneric ? node.typeParameters != null : node.typeParameters == null);
    if (node.isGeneric) {
      node.typeParameters = this.visit(node.typeParameters);
    }
    if (node.extendsType) {
      node.extendsType = this.visit(node.extendsType);
    }
    node.implementsTypes = this.visit(node.implementsTypes);
    node.members = this.visit(node.members);
    this.depth--;
    return node;
  }
  visitDoStatement(node) {
    node.condition = this.visit(node.condition);
    node.statement = this.visit(node.statement);
    return node;
  }
  visitEmptyStatement(node) {
    return node;
  }
  visitEnumDeclaration(node, isDefault) {
    node.name = this.visit(node.name);
    node.decorators = this.visit(node.decorators);
    node.values = this.visit(node.values);
    return node;
  }
  visitEnumValueDeclaration(node) {
    node.name = this.visit(node.name);
    if (node.initializer) {
      node.initializer = this.visit(node.initializer);
    }
    return node;
  }
  visitExportImportStatement(node) {
    node.name = this.visit(node.name);
    node.externalName = this.visit(node.externalName);
    return node;
  }
  visitExportMember(node) {
    node.localName = this.visit(node.localName);
    node.exportedName = this.visit(node.exportedName);
    return node;
  }
  visitExportStatement(node) {
    if (node.path) {
      node.path = this.visit(node.path);
    }
    node.members = this.visit(node.members);
    return node;
  }
  visitExportDefaultStatement(node) {
    node.declaration = this.visit(node.declaration);
    return node;
  }
  visitExpressionStatement(node) {
    node.expression = this.visit(node.expression);
    return node;
  }
  visitFieldDeclaration(node) {
    node.name = this.visit(node.name);
    if (node.type) {
      node.type = this.visit(node.type);
    }
    if (node.initializer) {
      node.initializer = this.visit(node.initializer);
    }
    node.decorators = this.visit(node.decorators);
    return node;
  }
  visitForStatement(node) {
    if (node.initializer) node.initializer = this.visit(node.initializer);
    if (node.condition) node.condition = this.visit(node.condition);
    if (node.incrementor) node.incrementor = this.visit(node.incrementor);
    node.statement = this.visit(node.statement);
    return node;
  }
  visitFunctionDeclaration(node, isDefault) {
    node.name = this.visit(node.name);
    node.decorators = this.visit(node.decorators);
    if (node.isGeneric) {
      node.typeParameters = this.visit(node.typeParameters);
    }
    node.signature = this.visit(node.signature);
    this.depth++;
    if (node.body) node.body = this.visit(node.body);
    this.depth--;
    return node;
  }
  visitFunctionCommon(node) {
    return node;
  }
  visitIfStatement(node) {
    node.condition = this.visit(node.condition);
    node.ifTrue = this.visit(node.ifTrue);
    if (node.ifFalse) node.ifFalse = this.visit(node.ifFalse);
    return node;
  }
  visitImportDeclaration(node) {
    node.foreignName = this.visit(node.foreignName);
    node.name = this.visit(node.name);
    node.decorators = this.visit(node.decorators);
    return node;
  }
  visitImportStatement(node) {
    if (node.namespaceName) node.namespaceName = this.visit(node.namespaceName);
    node.declarations = this.visit(node.declarations);
    return node;
  }
  visitIndexSignature(node) {
    return node;
  }
  visitInterfaceDeclaration(node, isDefault) {
    node.name = this.visit(node.name);
    if (node.isGeneric) {
      node.typeParameters = this.visit(node.typeParameters);
    }
    node.implementsTypes = this.visit(node.implementsTypes);
    if (node.extendsType) node.extendsType = this.visit(node.extendsType);
    this.depth++;
    node.members = this.visit(node.members);
    this.depth--;
    return node;
  }
  visitMethodDeclaration(node) {
    node.name = this.visit(node.name);
    if (node.isGeneric) {
      node.typeParameters = this.visit(node.typeParameters);
    }
    node.signature = this.visit(node.signature);
    node.decorators = this.visit(node.decorators);
    this.depth++;
    if (node.body) node.body = this.visit(node.body);
    this.depth--;
    return node;
  }
  visitNamespaceDeclaration(node, isDefault) {
    node.name = this.visit(node.name);
    node.decorators = this.visit(node.decorators);
    node.members = this.visit(node.members);
    return node;
  }
  visitReturnStatement(node) {
    if (node.value) node.value = this.visit(node.value);
    return node;
  }
  visitSwitchCase(node) {
    if (node.label) node.label = this.visit(node.label);
    node.statements = this.visit(node.statements);
    return node;
  }
  visitSwitchStatement(node) {
    node.condition = this.visit(node.condition);
    this.depth++;
    node.cases = this.visit(node.cases);
    this.depth--;
    return node;
  }
  visitThrowStatement(node) {
    node.value = this.visit(node.value);
    return node;
  }
  visitTryStatement(node) {
    node.statements = this.visit(node.statements);
    if (node.catchVariable) node.catchVariable = this.visit(node.catchVariable);
    node.catchStatements = this.visit(node.catchStatements);
    node.finallyStatements = this.visit(node.finallyStatements);
    return node;
  }
  visitTypeDeclaration(node) {
    node.name = this.visit(node.name);
    node.decorators = this.visit(node.decorators);
    node.type = this.visit(node.type);
    node.typeParameters = this.visit(node.typeParameters);
    return node;
  }
  visitVariableDeclaration(node) {
    node.name = this.visit(node.name);
    if (node.type) node.type = this.visit(node.type);
    if (node.initializer) node.initializer = this.visit(node.initializer);
    return node;
  }
  visitVariableStatement(node) {
    node.decorators = this.visit(node.decorators);
    node.declarations = this.visit(node.declarations);
    return node;
  }
  visitWhileStatement(node) {
    node.condition = this.visit(node.condition);
    this.depth++;
    node.statement = this.visit(node.statement);
    this.depth--;
    return node;
  }
  visitVoidStatement(node) {
    return node;
  }
  visitComment(node) {
    return node;
  }
  visitDecoratorNode(node) {
    node.name = this.visit(node.name);
    node.args = this.visit(node.args);
    return node;
  }
  visitParameter(node) {
    node.name = this.visit(node.name);
    if (node.implicitFieldDeclaration) {
      node.implicitFieldDeclaration = this.visit(node.implicitFieldDeclaration);
    }
    if (node.initializer) node.initializer = this.visit(node.initializer);
    node.type = this.visit(node.type);
    return node;
  }
}
exports.BaseTransformVisitor = BaseTransformVisitor;
    